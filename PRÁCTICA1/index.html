<!DOCTYPE HTML>

<html lang="es">
<head>
    <!-- Datos que describen el documento, CODIFICACION DE CARACTERES -->
    <meta charset="UTF-8" />
    <title>Ruby</title>
    <!--Metadatos de los documentos HTML5-->
    <meta name ="author" content ="Lara Fernández Méndez" />
    <meta name ="description" content ="Información sobre el lenguaje de programación Ruby" />
    <meta name ="keywords" content ="Ruby, programación" />
    <!--Definición de la ventana gráfica-->
    <meta name ="viewport" content ="width=device-width, initial-scale=1.0" />
    <!-- añadir el elemento link de enlace a la hoja de estilo dentro del <head> del documento html -->
    <link rel="stylesheet" type="text/css" href="estilo/estilo.css" />
    <link rel="stylesheet" type="text/css" href="estilo/layout.css" />
</head>

<body>
<header> <h1>Lenguaje Ruby</h1></header>
<nav>
    <a accesskey="R" tabindex="1" href="index.html">Ruby </a> 
    <a accesskey="V" tabindex="2" href="versiones.html">Versiones </a> 
    <a accesskey="T" tabindex="3" href="tablaversiones.html">Tabla de Versiones </a> 
    <a accesskey="O" tabindex="4" href="opiniones.html">Diganos su opinión </a> 
    <a accesskey="I" tabindex="4" href="instalacion.html">Como instalar </a> 
</nav>

<main>
    <!-- Datos con el contenidos que aparece en el navegador -->
   
   <section>
    <h2>Ruby</h2>
    <p>
        Ruby es un lenguaje de programación interpretado, reflexivo y orientado a objetos, creado por el programador japonés Yukihiro "Matz" Matsumoto. Combina una sintaxis inspirada en Python y Perl.
    </p>
    <img src="multimedia/ruby.jpg" alt=" Ruby Logo" />
    </section>

    <section>
    <h2>Historia</h2>
    <p>El lenguaje fue creado por <strong>Yukihiro "Matz" Matsumoto</strong>, quien empezó a trabajar en Ruby el 24 de febrero de 1993, y lo presentó al público en el año 1995. 
        Diferencias en rendimiento entre la actual implementación de Ruby (1.8.6) y otros lenguajes de programación más arraigados han llevado al desarrollo de 
        varias máquinas virtuales para Ruby. Entre esas se encuentra  <strong>JRuby</strong>, un intento de llevar Ruby a la plataforma <strong>Java</strong>, y <strong>Rubinius</strong>, un intérprete modelado 
        basado en las máquinas virtuales de <strong>Smalltalk</strong>. 
    </p>
    <img src="multimedia/Yukihiro_Matsumoto.jpg" alt=" Yukihiro Matsumoto" />
   
    <h2>Filosofia</h2>
    <p>
        <strong>Yukihiro Matsumoto</strong> ha dicho que Ruby está diseñado para la productividad y la diversión del desarrollador, siguiendo los principios de una buena interfaz 
        de usuario. Sostiene que el diseño de sistemas necesita enfatizar las necesidades humanas más que las de la máquina.​
    </p>
  
    <h2>Semántica</h2>
    <p>
        Ruby es <strong>orientado a objetos</strong>: todos los tipos de datos son un objeto, incluidas las clases y tipos que otros lenguajes definen como primitivas. Toda <strong>función</strong> es un <strong>método</strong>.
        Las variables siempre son referencias a objetos, no los objetos mismos. Ruby soporta <strong>herencia</strong> con <strong>enlace dinámico, mixins y métodos singleton</strong> (pertenecientes y definidos por una sola <strong>instancia</strong> más que definidos por la clase). 
        A pesar de que Ruby no soporta <strong>herencia múltiple</strong>, las clases pueden importar <strong>módulos</strong>.
        Es compatible con la sintaxis procedimental, pero todos los métodos definidos fuera del ámbito de un objeto son realmente métodos de la clase Object. Como esta clase es padre de todas las demás, los cambios son visibles para todas las clases y objetos.
    </p>
    <p>
        Ruby ha sido descrito como un <strong>lenguaje de programación multiparadigma</strong>: permite <strong>programación procedimental</strong> (definiendo funciones y variables fuera de las clases 
        haciéndolas parte del objeto raíz Object), con orientación a objetos, (todo es un objeto) o <strong>funcionalmente</strong> (tiene funciones anónimas, <strong>clausuras y continuaciones</strong>; 
        todas las sentencias tienen valores, y las funciones devuelven la última evaluación). Soporta <strong>introspección, reflexión y metaprogramación</strong>, además de soporte para 
        <strong>hilos de ejecución</strong> gestionados por el intérprete. Ruby tiene <strong>tipado</strong> dinámico, y soporta <strong>polimorfismo</strong> de tipos (permite tratar a subclases utilizando la interfaz de 
        la clase padre). Ruby no requiere de polimorfismo de funciones (sobrecarga de funciones) al ser dinámicamente tipado (los parámetros de una función pueden ser de 
        distinto tipo en cada llamada, encargándose dicha función de determinar el tipo y actuar en consecuencia).
    </p>
   
    <h2>Sintaxis</h2>
    <p>
        La sintaxis de Ruby es similar a la de Perl o Python. La definición de clases y métodos está definida por palabras clave. Sin embargo, en Perl, 
        las variables no llevan prefijos. Cuando se usa, un prefijo indica el ámbito de las variables. La mayor diferencia con C y Perl es que las palabras clave 
        son usadas para definir bloques de código sin llaves. Los saltos de línea son significativos y son interpretados como el final de una sentencia; 
        el punto y coma tiene el mismo uso. A diferencia de Python, la sangría no es significativa.
    </p>
    <p>
        Una de las diferencias entre Ruby y Python y Perl es que Ruby mantiene todas sus variables de instancia privadas dentro de las clases y solo la expone a través 
        de métodos de acceso. A diferencia de los métodos get y set de otros lenguajes como C++ o Java, los métodos de acceso en Ruby pueden ser escritos con una sola 
        línea de código. Como la invocación de estos métodos no requiere el uso de paréntesis, es trivial cambiar una variable de instancia en una función sin tocar una 
        sola línea de código o refactorizar dicho código. Los descriptores de propiedades de Python son similares pero tienen una desventaja en el proceso de desarrollo. 
        Si uno comienza en Python usando una instancia de variable expuesta públicamente y después cambia la implementación para usar una instancia de variable privada 
        expuesta a través de un descriptor de propiedades, el código interno de la clase necesitará ser ajustado para usar la variable privada en vez de la propiedad pública. 
        Ruby elimina está decisión de diseño obligando a todas las variables de instancia a ser privadas, pero también proporciona una manera sencilla de declarar métodos 
        set y get. Esto mantiene el principio de que en Ruby no se puede acceder a los miembros internos de una clase desde fuera de esta; en lugar de esto se pasa un 
        mensaje a la clase y recibe una respuesta.
    </p>

    <h2>Resumen</h2>
    <p> 
        Para finalizar, dejaremos un audio con un pequeño resumen de lo visto hasta ahora:
    </p>
    <audio src="multimedia/introduccion.mp3" controls> </audio>

   
  
    <!-- la carpeta de recursos gráficos "images" debe estar en el misma carpeta del archivo -->
    <!-- anadir la sección footer dentro del body despues del párrafo -->
    </section>
</main>
<footer>
    <p>
        Todos los derechos reservados a Ruby.
    </p>
</footer>

</body>
</html>